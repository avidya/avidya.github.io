好！趁记忆还新鲜，先把昨天解决的一个bug过程记录一下吧，还是挺有意义的，对日后同类错误排查很有指导价值。
最初，bug的表现是，使用tcsession的应用crm，对于tcsession的远端存储（目前是zookeeper）连接数过高。然后系统失去响应，意即拒绝一切请求，并且在日志里反复打连接异常错误。
昨天下午再次出现这个症状，当时用jstack $pid反复杀了几次堆栈。发现都存在300多个BLOCKED线程，形如：
"http-8083-200" daemon prio=10 tid=0x00007f6e9c193000 nid=0x70b4 waiting for monitor entry [0x00007f6e516cf000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at org.apache.commons.pool.impl.StackObjectPool.borrowObject(StackObjectPool.java:139)
    - waiting to lock <0x00000007856fd578> (a org.apache.commons.pool.impl.StackObjectPool)
    at com.tc.session.ZookeeperPoolManager.borrowObject(ZookeeperPoolManager.java:79)
    at com.tc.session.zookeeper.ZookeeperSessionClient.removeSession(ZookeeperSessionClient.java:319)
    at com.tc.session.TCSession.invalidate(TCSession.java:330)
    at org.jasig.cas.client.session.SingleSignOutHandler.destroySession(SingleSignOutHandler.java:150)
    at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:58)
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
    at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105)
在绕了很多弯路后，开始仔细检索org.apache.commons.pool.impl.StackObjectPool的borrowObject方法。
该方法用synchronized修饰，意即调用方必须在获得StackObjectPool对象实例的内置锁之后，才可以进入调用方法的同步块。阻塞的原因就是因为无法获得锁。下面这行很重要！
    at org.apache.commons.pool.impl.StackObjectPool.borrowObject(StackObjectPool.java:139)
    - waiting to lock <0x00000007856fd578> (a org.apache.commons.pool.impl.StackObjectPool)
在这里，jvm已经明确指出了，等待的锁的对象ID是0x00000007856fd578。
于是在杀出的栈信息里面找到：
"http-8083-31" daemon prio=10 tid=0x00007f6e9c017000 nid=0xbd7 waiting on condition [0x00007f6e5fbb2000]
   java.lang.Thread.State: WAITING (parking)
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00000007888deda8> (a java.util.concurrent.CountDownLatch$Sync)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:969)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:207)
    at com.tc.session.ZookeeperConnector.connect(ZookeeperConnector.java:40)
    at com.tc.session.ZookeeperPoolableObjectFactory.makeObject(ZookeeperPoolableObjectFactory.java:29)
    at com.tc.session.ZookeeperPoolableObjectFactory.makeObject(ZookeeperPoolableObjectFactory.java:17)
    at org.apache.commons.pool.impl.StackObjectPool.borrowObject(StackObjectPool.java:149)
    - locked <0x00000007856fd578> (a org.apache.commons.pool.impl.StackObjectPool)
    at com.tc.session.ZookeeperPoolManager.borrowObject(ZookeeperPoolManager.java:79)
    at com.tc.session.zookeeper.ZookeeperSessionClient.removeSession(ZookeeperSessionClient.java:319)
    at com.tc.session.TCSession.invalidate(TCSession.java:330)
    at org.jasig.cas.client.session.SingleSignOutHandler.destroySession(SingleSignOutHandler.java:150)
很显然，正是由于这个线程持有了之前提及的对象锁，又长期不释放，才导致了其它线程的阻塞。那么就接着分析这个方法不释放锁的原因。
栈顶是concorrent包的信息，而concorrent包的调用方是：com.tc.session.ZookeeperConnector的connect方法。该方法实现如下：
public class ZookeeperConnector implements Watcher {

    private CountDownLatch signal = new CountDownLatch(1);

    private static final Logger log = LoggerFactory.getLogger(ZookeeperConnector.class);

    /**
     * 连接ZK客户端，通过CDL作同步。
     *
     * @param servers
     * @param sessionTimeout
     * @return
     */
    public ZooKeeper connect(String servers, int sessionTimeout) {

        ZooKeeper zk;
        try {
            zk = new ZooKeeper(servers, sessionTimeout, this);
            signal.await();
            return zk;
        } catch (IOException e) {
            log.error("", e);
        } catch (InterruptedException e) {
            log.error("", e);
        }
        return null;
    }

    @Override
    public void process(WatchedEvent event) {

        KeeperState state = event.getState();
        if (state == KeeperState.SyncConnected) {
            signal.countDown();
        }else if(state == KeeperState.Disconnected || state == KeeperState.Expired){
            log.info("Disconnected from Zookeeper Server! ");
        }
    }
}
connect 方法的主要用途是与zookeeper服务器建立连接。但工程师实现的时候，基于程序健壮性因素的考量，并没有把刚刚建立连接引用，立即返回给调用者。原 因是，这时返回的连接引用，很可能还没有完成必要的握手步骤。这里用到的trick是借助CountDownLatch（俗称线程发令枪）和 Watcher.process(WatchedEvent event)回调接口共同完成的。大致流程如下，在connect方法中，建立连接之后，依靠CountDownLatch实例的一个信号量，达成阻塞。 因为该类实现了org.apache.zookeeper.Watcher接口，所以，在连接状态发生变化时，可以回调process()方法。在 process方法中，当判断连接状态为已连接（SyncConnected）时，调用信号量的countDown()（因为初始为1,所以一个 countDown调用即可以打开阀），原先通过await()阻塞在信号量上的connect()线程就得以继续执行了。但这里存在的问题是，在异常发 生时，譬如网络不同畅，zk服务器工作不稳定等，回调方法体并没有进入countDown执行分支。导致了一个信号量的丢失！而且，检查连接状态值，在某 些可能导致永远无法从一个失败的连接状态复原。这就是导致问题的罪魁祸首！
好吧，bug分析到此为止，多线程问题的处理有时候确实可能颇为棘手，常规的debug手段也会显得比较无力，此文仅作抛砖引玉之用，如果大家也有类似痛苦，但最后解决后感到有所收获的bugfix经历，也欢迎一起来分享！

